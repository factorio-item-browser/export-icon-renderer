package filter

import (
	"github.com/factorio-item-browser/export-icon-renderer/pkg/transfer"
	"github.com/stretchr/testify/assert"
	"image"
	"testing"
)

func TestRemoveMipMaps(t *testing.T) {
	layer := transfer.Layer{
		Size: 2,
	}
	props := Properties{}
	source := image.RGBA{
		Pix: []uint8{
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
			0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
		},
		Stride: 12,
		Rect:   image.Rect(0, 0, 3, 3),
	}
	expectedResult := image.RGBA{
		Pix: []uint8{
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		},
		Stride: 8,
		Rect:   image.Rect(0, 0, 2, 2),
	}

	result := RemoveMipMaps(&source, layer, props)

	assert.Equal(t, &expectedResult, result)
}

func TestScale(t *testing.T) {
	layer := transfer.Layer{
		Size:  2,
		Scale: 0.75,
	}
	props := Properties{
		RenderedScale: 2.,
	}
	source := image.RGBA{
		Pix: []uint8{
			0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
			0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF,
		},
		Stride: 8,
		Rect:   image.Rect(0, 0, 2, 2),
	}
	expectedResult := image.RGBA{
		Pix: []uint8{
			0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
			0x80, 0x00, 0x80, 0xFF, 0x80, 0x00, 0x80, 0xFF, 0x80, 0x00, 0x80, 0xFF,
			0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF,
		},
		Stride: 12,
		Rect:   image.Rect(0, 0, 3, 3),
	}

	result := Scale(&source, layer, props)

	assert.Equal(t, &expectedResult, result)
}

func TestScale_Skip(t *testing.T) {
	layer := transfer.Layer{
		Size:  2,
		Scale: 0.5,
	}
	props := Properties{
		RenderedScale: 2.,
	}
	source := image.RGBA{
		Pix: []uint8{
			0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
			0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF,
		},
		Stride: 8,
		Rect:   image.Rect(0, 0, 2, 2),
	}

	result := Scale(&source, layer, props)

	assert.Exactly(t, &source, result)
}

func TestOffset(t *testing.T) {
	layer := transfer.Layer{
		Offset: transfer.Offset{
			X: 2,
			Y: 4,
		},
	}
	props := Properties{
		RenderedSize:  2,
		RenderedScale: 0.5,
	}
	source := image.RGBA{
		Pix: []uint8{
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		},
		Stride: 8,
		Rect:   image.Rect(0, 0, 2, 2),
	}
	expectedResult := image.RGBA{
		Pix: []uint8{
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
		},
		Stride: 24,
		Rect:   image.Rect(0, 0, 6, 6),
	}

	result := Offset(&source, layer, props)

	assert.Equal(t, &expectedResult, result)
}

func TestOffset_Skip(t *testing.T) {
	layer := transfer.Layer{
		Offset: transfer.Offset{
			X: 0,
			Y: 0,
		},
	}
	props := Properties{
		RenderedScale: 2.,
	}
	source := image.RGBA{
		Pix: []uint8{
			0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
			0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF,
		},
		Stride: 8,
		Rect:   image.Rect(0, 0, 2, 2),
	}

	result := Offset(&source, layer, props)

	assert.Exactly(t, &source, result)
}

func TestExpand(t *testing.T) {
	layer := transfer.Layer{}
	props := Properties{
		RenderedSize: 2.,
	}
	source := image.RGBA{
		Pix: []uint8{
			0xFF, 0xFF, 0xFF, 0xFF,
		},
		Stride: 4,
		Rect:   image.Rect(0, 0, 1, 1),
	}
	expectedResult := image.RGBA{
		Pix: []uint8{
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		},
		Stride: 20,
		Rect:   image.Rect(0, 0, 5, 5),
	}

	result := Expand(&source, layer, props)

	assert.Equal(t, &expectedResult, result)
}

func TestExpand_Skip(t *testing.T) {
	layer := transfer.Layer{}
	props := Properties{
		RenderedScale: 2.,
	}
	source := image.RGBA{
		Pix: []uint8{
			0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
			0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF,
		},
		Stride: 8,
		Rect:   image.Rect(0, 0, 2, 2),
	}

	result := Expand(&source, layer, props)

	assert.Exactly(t, &source, result)
}

func TestCrop(t *testing.T) {
	layer := transfer.Layer{}
	props := Properties{
		RenderedSize: 2.,
	}
	source := image.RGBA{
		Pix: []uint8{
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		},
		Stride: 16,
		Rect:   image.Rect(0, 0, 4, 4),
	}
	expectedResult := image.RGBA{
		Pix: []uint8{
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		},
		Stride: 8,
		Rect:   image.Rect(1, 1, 3, 3),
	}

	result := Crop(&source, layer, props)

	assert.Equal(t, &expectedResult, result)
}

func TestCrop_Skip(t *testing.T) {
	layer := transfer.Layer{}
	props := Properties{
		RenderedSize: 2.,
	}
	source := image.RGBA{
		Pix: []uint8{
			0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
			0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF,
		},
		Stride: 8,
		Rect:   image.Rect(0, 0, 2, 2),
	}

	result := Crop(&source, layer, props)

	assert.Exactly(t, &source, result)
}

func TestResizeToOutput(t *testing.T) {
	layer := transfer.Layer{}
	props := Properties{
		OutputSize: 3.,
	}
	source := image.RGBA{
		Pix: []uint8{
			0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
			0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF,
		},
		Stride: 8,
		Rect:   image.Rect(0, 0, 2, 2),
	}
	expectedResult := image.RGBA{
		Pix: []uint8{
			0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
			0x80, 0x00, 0x80, 0xFF, 0x80, 0x00, 0x80, 0xFF, 0x80, 0x00, 0x80, 0xFF,
			0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF,
		},
		Stride: 12,
		Rect:   image.Rect(0, 0, 3, 3),
	}

	result := ResizeToOutput(&source, layer, props)

	assert.Equal(t, &expectedResult, result)
}

func TestResizeToOutput_Skip(t *testing.T) {
	layer := transfer.Layer{}
	props := Properties{
		OutputSize: 2.,
	}
	source := image.RGBA{
		Pix: []uint8{
			0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
			0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF,
		},
		Stride: 8,
		Rect:   image.Rect(0, 0, 2, 2),
	}

	result := ResizeToOutput(&source, layer, props)

	assert.Exactly(t, &source, result)
}
